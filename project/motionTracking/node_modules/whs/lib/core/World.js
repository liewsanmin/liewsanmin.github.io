'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.World = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp;

var _three = require('three');

var _index = require('../physics/index.js');

var Physijs = _interopRequireWildcard(_index);

var _detectElementResize = require('detect-element-resize');

var _index2 = require('../utils/index');

var _PerspectiveCamera = require('../components/cameras/PerspectiveCamera');

var _BasicRendering = require('../components/rendering/basic/BasicRendering');

var _Component2 = require('./Component');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var World = (_temp = _class = function (_Component) {
  (0, _inherits3.default)(World, _Component);
  (0, _createClass3.default)(World, [{
    key: '$rendering',
    get: function get() {
      return this.modules.rendering;
    },
    set: function set(plugin) {
      this.modules.rendering = plugin(this);
    }
  }, {
    key: '$scene',
    get: function get() {
      return this.modules.scene;
    },
    set: function set(scene) {
      this.importScene(scene);
    }
  }, {
    key: '$camera',
    get: function get() {
      return this.modules.camera;
    },
    set: function set(camera) {
      this.modules.camera = camera;
    }
  }, {
    key: '$element',
    get: function get() {
      return this.modules.element;
    },
    set: function set(element) {
      this.modules.element = element;
    }
  }]);

  function World() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, World);

    var _this = (0, _possibleConstructorReturn3.default)(this, (World.__proto__ || (0, _getPrototypeOf2.default)(World)).call(this, params, World.defaults, World.instructions));

    _this.modules = {
      element: null,
      scene: null,
      camera: null,
      rendering: null,
      helpers: null,
      stats: null
    };
    _this.simulate = false;
    _this.render = true;
    _this.loops = [];


    for (var plugin in _this.modules) {
      if (World.pluginDeps[plugin]) {
        var dependencies = World.pluginDeps[plugin];
        var skip = false;

        for (var i = 0, max = dependencies.length; i < max; i++) {
          // console.log(dependencies[i]);
          if (!_this.params.modules[dependencies[i]]) skip = true;
        }

        if (skip) continue;
      }

      if (_this.params.modules[plugin] && _this['make$' + plugin]) _this['make$' + plugin]();
    }

    if (params.autoresize) {
      (function () {
        var container = params.container;

        var resizeCallback = function resizeCallback() {
          // FIXME: Am I crazy or offsetHeight is increasing even when we downsize the window ?
          // console.log('height offset : ', params.container.offsetHeight);

          _this.setSize(Number(container.offsetWidth * params.resolution.width).toFixed(), Number(container.offsetHeight * params.resolution.height).toFixed());

          _this.emit('resize');
        };

        if (params.autoresize === 'window') window.addEventListener('resize', resizeCallback);else {
          if (params.autoresize.delay) {
            (function () {
              var resize = true;

              (0, _detectElementResize.addResizeListener)(container, function () {
                window.clearTimeout(resize);
                resize = window.setTimeout(resizeCallback, params.autoresize.delay);
              });
            })();
          } else (0, _detectElementResize.addResizeListener)(container, resizeCallback);
        }
      })();
    }
    return _this;
  }

  (0, _createClass3.default)(World, [{
    key: 'make$scene',
    value: function make$scene() {
      var params = this.params;
      var scene = Physijs.default !== false ? new Physijs.Scene({
        fixedTimeStep: params.physics.fixedTimeStep,
        broadphase: params.physics.broadphase
      }, {
        stats: params.stats,
        world: this,
        softbody: params.softbody
      }) : new _three.Scene();

      if (Physijs.default !== false) {
        scene.setGravity(new _three.Vector3(params.gravity.x, params.gravity.y, params.gravity.z));

        scene.simulate();
        this.simulate = true;
      }

      if (params.fog.type === 'regular') scene.fog = new _three.Fog(params.fog.hex, params.fog.near, params.fog.far);else if (params.fog.type === 'exp' || params.fog.type === 'expodential') scene.fog = new _three.FogExp2(params.fog.hex, params.fog.density);

      this.importScene(scene, false);
    }
  }, {
    key: 'make$element',
    value: function make$element() {
      this.$element = window.document.createElement('div');
      this.$element.className = 'whs';
      this.$element.style.width = 'inherit';
      this.$element.style.height = 'inherit';
      this.params.container.appendChild(this.$element);

      return this.$element;
    }
  }, {
    key: 'make$camera',
    value: function make$camera() {
      var _params = this.params;

      this.$camera = new _PerspectiveCamera.PerspectiveCamera({
        camera: {
          fov: _params.camera.fov,
          aspect: _params.width / _params.height,
          near: _params.camera.near,
          far: _params.camera.far
        },

        position: {
          x: _params.camera.position.x,
          y: _params.camera.position.y,
          z: _params.camera.position.z
        }
      });

      this.$camera.addTo(this);
    }
  }, {
    key: 'make$rendering',
    value: function make$rendering() {
      var _params = this.params;
      var computedWidth = Number(_params.width * _params.resolution.width).toFixed();
      var computedHeight = Number(_params.height * _params.resolution.height).toFixed();

      this.$rendering = new _BasicRendering.BasicRendering(this.params);
    }
  }, {
    key: 'make$helpers',
    value: function make$helpers() {
      var _helpers = this.params.helpers;

      if (_helpers.axis) this.addHelper('axis', _helpers.axis);
      if (_helpers.grid) this.addHelper('grid', _helpers.grid);
    }

    /**
     * Start animation.
     */

  }, {
    key: 'start',
    value: function start() {
      if (this.$rendering) this.$rendering.start(this.beforeRender.bind(this), this.afterRender.bind(this));
    }

    /**
     * Callback called immediately before Plugin Rendering.
     * @param  {Number} delta : delta time elapsed since the last frame.
     */

  }, {
    key: 'beforeRender',
    value: function beforeRender(delta) {
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i].type === 'morph') this.children[i].native.mixer.update(delta);
      }if (this.controls) {
        this.controls.update(Date.now() - this.time);
        this.time = Date.now();
      };

      if (this.simulate) this.$scene.simulate(delta, 1);
    }

    /**
     * Callback called immediately after the Plugin Rendering.
     * @param  {Number} delta : delta time elapsed since the last frame (will be equal to beforeRender delta).
     */

  }, {
    key: 'afterRender',
    value: function afterRender(delta) {
      for (var i = 0; i < this.loops.length; i++) {
        var e = this.loops[i];
        if (e.enabled) e.execute(e.clock);
      }
    }

    /**
     * Retrieve the renderer used by the active rendering plugin.
     * @return {THREE.WebGLRenderer} The WebGLRenderer used by the current rendering plugin.
     */

  }, {
    key: 'addLoop',
    value: function addLoop(loop) {
      var _this2 = this;

      return new _promise2.default(function (resolve) {
        _this2.loops.push(loop);
        resolve(loop);
      });
    }
  }, {
    key: 'removeLoop',
    value: function removeLoop(loop) {
      var _this3 = this;

      return new _promise2.default(function (resolve) {
        _this3.loops.filter(function (l) {
          return l !== loop;
        });
        resolve(loop);
      });
    }
  }, {
    key: 'addHelper',
    value: function addHelper(name) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var helpers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : World.helpers;

      (0, _get3.default)(World.prototype.__proto__ || (0, _getPrototypeOf2.default)(World.prototype), 'addHelper', this).call(this, name, params, helpers);
    }
  }, {
    key: 'addConstraint',
    value: function addConstraint(constraint) {
      this.$scene.addConstraint(constraint);
    }

    /**
     * This functon will scene properties when it's called.
     */

  }, {
    key: 'setSize',
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this.$camera.native.aspect = width / height;
      this.$camera.native.updateProjectionMatrix();

      if (this.$rendering) {
        this.$rendering.setSize(width, height);
      }
    }
  }, {
    key: 'importScene',
    value: function importScene(scene) {
      var _this4 = this;

      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.modules.scene = scene;

      if (nested) {
        (function () {
          _this4.children = [];

          var moveChildren = function moveChildren(object) {
            for (var i = 0, max = object.children.length; i < max; i++) {
              var obj3D = object.children[i];
              var WHSobj = void 0;

              WHSobj = new _Component2.Component(obj3D);
              WHSobj.addTo(_this4);

              if (obj3D.children.length) moveChildren(obj3D, WHSobj);
            }
          };

          moveChildren(scene, _this4);
        })();
      }

      return this.$scene;
    }
  }, {
    key: 'setControls',
    value: function setControls(controls) {
      var recieved = controls.integrate(this);

      this.controls = recieved instanceof Array ? recieved[0] : recieved;

      if (recieved instanceof Array && typeof recieved[1] === 'function') recieved[1](this);

      return this.controls;
    }
  }, {
    key: 'renderer',
    get: function get() {
      if (this.$rendering) return this.$rendering.$renderer;
    }
  }]);
  return World;
}(_Component2.Component), _class.defaults = {
  stats: false,
  autoresize: false,
  softbody: false,

  helpers: {
    grid: false,
    axis: false
  },

  gravity: {
    x: 0,
    y: 0,
    z: 0
  },

  rendering: {
    shadowmap: {
      enabled: true,
      type: _three.PCFSoftShadowMap
    },

    background: {
      color: 0x000000,
      opacity: 1
    },

    renderer: {}
  },

  camera: {
    fov: 75,
    near: 1,
    far: 1000,

    position: {
      x: 0,
      y: 0,
      z: 0
    }
  },

  width: window.innerWidth,
  height: window.innerHeight,
  container: window.document.body,

  resolution: {
    width: 1,
    height: 1
  },

  physics: {
    fixedTimeStep: 1 / 60,
    broadphase: { type: 'dynamic' }
  },

  fog: {
    type: false,

    density: 0.00025,
    hex: 0x000000,
    near: 1,
    far: 1000
  },

  modules: {
    element: true,
    scene: true,
    stats: true,
    camera: true,
    helpers: true,
    rendering: true
  }
}, _class.instructions = {
  camera: {
    position: ['x', 'y', 'z']
  },

  gravity: ['x', 'y', 'z'],

  modules: ['element', 'scene', 'stats', 'camera', 'helpers', 'rendering']
}, _class.helpers = {
  axis: [_three.AxisHelper, {
    size: 5
  }, ['size']],

  grid: [_three.GridHelper, {
    size: 10,
    step: 1,
    color1: 0xffffff,
    color2: 0xffffff
  }, ['size', 'step', 'color1', 'color2']]
}, _class.pluginDeps = {
  'camera': ['scene'],
  'rendering': ['scene'],
  'helpers': ['scene']
}, _temp);
exports.World = World;